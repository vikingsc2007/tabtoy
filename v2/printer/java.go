package printer

import (
	"fmt"
	"text/template"

	"bytes"
	"crypto/md5"
	"github.com/vikingsc2007/tabtoy/v2/i18n"
	"github.com/vikingsc2007/tabtoy/v2/model"
	"strings"
)

const javaTemplate = `// Generated by github.com/vikingsc2007/tabtoy
// Version: {{.ToolVersion}}
// DO NOT EDIT!!

package com.tabtoy.{{.Namespace}}{{$globalIndex:=.Indexes}}{{$verticalFields:=.VerticalFields}};

import com.tabtoy.*;
import java.util.ArrayList;
import java.util.Hashtable;


{{range .Enums}}
// Defined in table: {{.DefinedTable}}
public enum {{.Name}}
{
{{range .Fields}}	
	{{.Comment}}
	{{.FieldDescriptor.Name}}, {{.Alias}}
{{end}}
}
{{end}}
{{range .Classes}}

// Defined in table: {{.DefinedTable}}
{{.JavaClassHeader}}
public class {{.Name}}
{
{{if .IsCombine}}
	public Logger TableLogger = new Logger();
{{end}}
{{range .Fields}}	
	{{.Comment}}
	{{.TypeCode}} {{.Alias}}
{{end}}
{{if .IsCombine}}
	//region Index code
	{{range $globalIndex}}Hashtable<{{.IndexType}}, {{.RowType}}> _{{.RowName}}By{{.IndexName}} = new Hashtable<{{.IndexType}}, {{.RowType}}>();
	public {{.RowType}} Get{{.RowName}}By{{.IndexName}}({{.IndexType}} {{.IndexName}})
	{
		return Get{{.RowName}}By{{.IndexName}}({{.IndexName}},null);
	}
	public {{.RowType}} Get{{.RowName}}By{{.IndexName}}({{.IndexType}} {{.IndexName}}, {{.RowType}} def)
	{        
		if ( _{{.RowName}}By{{.IndexName}}.containsKey({{.IndexName}}) )
		{
			return _{{.RowName}}By{{.IndexName}}.get({{.IndexName}});
		}

		TableLogger.ErrorLine("Get{{.RowName}}By{{.IndexName}} failed, {{.IndexName}}: {0}", {{.IndexName}});

		return def;       
    }
	{{end}}
	public String GetBuildID(){
		return "{{$.BuildID}}";
	}
{{range $verticalFields}}
	public {{.StructName}} Get{{.Name}}( )
	{
		return {{.Name}}[0];
	}	
{{end}}
	//endregion
	//region Deserialize code
	{{range $.Classes}}
	static DeserializeHandler<{{.Name}}> _{{.Name}}DeserializeHandler;
	static DeserializeHandler<{{.Name}}> get{{.Name}}DeserializeHandler()
	{
		if (_{{.Name}}DeserializeHandler == null )
		{
			_{{.Name}}DeserializeHandler = new DeserializeHandler<{{.Name}}>() {
				@Override
				public void Deserialize({{.Name}} ins, DataReader reader) throws Exception {
					{{ if $.GenSerializeCode }}
					int tag = -1;
					while ( -1 != (tag = reader.ReadTag()))
					{
						switch (tag)
						{ {{range .Fields}}
							case {{.Tag}}:
							{
								{{.ReadCode}}
							}
							break; {{end}}
						}
					} {{end}}
					{{range $a, $row :=.IndexedFields}}
					// Build {{$row.FieldDescriptor.Name}} Index
					for( int i = 0;i< ins.{{$row.FieldDescriptor.Name}}.size();i++)
					{
						{{$row.Complex.Name}} element = ins.{{$row.FieldDescriptor.Name}}.get(i);
						{{range $b, $key := .IndexKeys}}
						ins._{{$row.FieldDescriptor.Name}}By{{$key.Name}}.put(element.{{$key.Name}}, element);
						{{end}}
					}
					{{end}}
				}
			};
		}
		return _{{.Name}}DeserializeHandler;
	}
	{{end}}
	//endregion
{{end}}

} {{end}}


`

type javaIndexField struct {
	TableIndex
}

func (self javaIndexField) IndexName() string {
	return self.Index.Name
}

func (self javaIndexField) RowType() string {
	return self.Row.Complex.Name
}

func (self javaIndexField) RowName() string {
	return self.Row.Name
}

func (self javaIndexField) IndexType() string {

	switch self.Index.Type {
	case model.FieldType_Int32:
		return "Integer"
	case model.FieldType_UInt32:
		return "Long"
	case model.FieldType_Int64:
		return "Long"
	case model.FieldType_UInt64:
		return "Long"
	case model.FieldType_String:
		return "String"
	case model.FieldType_Float:
		return "Float"
	case model.FieldType_Bool:
		return "Boolean"
	case model.FieldType_Enum:
		return self.Index.Complex.Name
	default:
		log.Errorf("%s can not be index ", self.Index.String())
	}

	return "unknown"
}

type javaField struct {
	*model.FieldDescriptor

	IndexKeys []*model.FieldDescriptor

	parentStruct *javaStructModel
}

func (self javaField) Alias() string {

	v := self.FieldDescriptor.Meta.GetString("Alias")
	if v == "" {
		return ""
	}

	return "// " + v
}

func (self javaField) Comment() string {

	if self.FieldDescriptor.Comment == "" {
		return ""
	}

	// zjwps 建议修改
	return "/// <summary> \n		/// " + strings.Replace(self.FieldDescriptor.Comment, "\n", "\n		///", -1) + "\n		/// </summary>"
}

func (self javaField) ReadCode() string {

	var baseType string

	var descHandlerCode string

	switch self.Type {
	case model.FieldType_Int32:
		baseType = "Int32"
	case model.FieldType_UInt32:
		baseType = "UInt32"
	case model.FieldType_Int64:
		baseType = "Int64"
	case model.FieldType_UInt64:
		baseType = "UInt64"
	case model.FieldType_String:
		baseType = "String"
	case model.FieldType_Float:
		baseType = "Float"
	case model.FieldType_Bool:
		baseType = "Bool"
	case model.FieldType_Enum:

		if self.Complex == nil {
			return "unknown"
		}

		baseType = fmt.Sprintf("Enum<%s>", self.Complex.Name)

	case model.FieldType_Struct:
		if self.Complex == nil {
			return "unknown"
		}

		baseType = fmt.Sprintf("Struct<%s>", self.Complex.Name)

	}

	if self.Type == model.FieldType_Struct {
		descHandlerCode = fmt.Sprintf("%sDeserializeHandler", self.Complex.Name)
	}

	if self.IsRepeated {
		if self.Type == model.FieldType_Enum {
			return fmt.Sprintf("ins.%s.add( reader.ReadEnum(%s.class) );",  self.Name, self.Complex.Name)
		}else if self.Type == model.FieldType_Struct{
			return fmt.Sprintf("ins.%s.add( reader.ReadStruct(%s.class,get%s()));", self.Name, self.Complex.Name, descHandlerCode)
		}else{
			return fmt.Sprintf("ins.%s.add( reader.Read%s(%s) );", self.Name, baseType, descHandlerCode)
		}
	} else {
		if self.Type == model.FieldType_Enum {
			return fmt.Sprintf("ins.%s = reader.ReadEnum(%s.class);", self.Name, self.Complex.Name)
		}else if self.Type == model.FieldType_Struct{
			return fmt.Sprintf("ins.%s = reader.ReadStruct(%s.class,get%s());", self.Name, self.Complex.Name, descHandlerCode)
		}else{
			return fmt.Sprintf("ins.%s = reader.Read%s(%s);", self.Name, baseType, descHandlerCode)
		}
		
	}

}

func (self javaField) Tag() string {

	if self.parentStruct.IsCombine() {
		tag := model.MakeTag(int32(model.FieldType_Table), self.Order)

		return fmt.Sprintf("0x%x", tag)
	}

	return fmt.Sprintf("0x%x", self.FieldDescriptor.Tag())
}

func (self javaField) StructName() string {
	if self.Complex == nil {
		return "[NotComplex]"
	}

	return self.Complex.Name
}

func (self javaField) IsVerticalStruct() bool {
	if self.FieldDescriptor.Complex == nil {
		return false
	}

	return self.FieldDescriptor.Complex.File.Pragma.GetBool("Vertical")
}

func (self javaField) TypeCode() string {

	var raw string

	switch self.Type {
	case model.FieldType_Int32:
		if !self.IsRepeated {
			raw = "int"
		}else{
			raw = "Integer"
		}
	case model.FieldType_UInt32:
		if !self.IsRepeated {
			raw = "long"
		}else{
			raw = "Long"
		}
	case model.FieldType_Int64:
		if !self.IsRepeated {
			raw = "long"
		}else{
			raw = "Long"
		}
	case model.FieldType_UInt64:
		if !self.IsRepeated {
			raw = "long"
		}else{
			raw = "Long"
		}
	case model.FieldType_String:
		raw = "String"
	case model.FieldType_Float:
		if !self.IsRepeated {
			raw = "float"
		}else{
			raw = "Float"
		}
	case model.FieldType_Bool:
		if !self.IsRepeated {
			raw = "boolean"
		}else{
			raw = "Boolean"
		}
	case model.FieldType_Enum:
		if self.Complex == nil {
			log.Errorln("unknown enum type ", self.Type)
			return "unknown"
		}

		raw = self.Complex.Name
	case model.FieldType_Struct:
		if self.Complex == nil {
			log.Errorln("unknown struct type ", self.Type, self.FieldDescriptor.Name, self.FieldDescriptor.Parent.Name)
			return "unknown"
		}

		raw = self.Complex.Name

		// 非repeated的结构体
		if !self.IsRepeated {
			return fmt.Sprintf("public %s %s = new %s();", raw, self.Name, raw)
		}

	default:
		raw = "unknown"
	}

	if self.IsRepeated {
		return fmt.Sprintf("public ArrayList<%s> %s = new ArrayList<%s>();", raw, self.Name, raw)
	}

	return fmt.Sprintf("public %s %s = %s;", raw, self.Name, wrapJavaDefaultValue(self.FieldDescriptor))
}

func wrapJavaDefaultValue(fd *model.FieldDescriptor) string {
	switch fd.Type {
	case model.FieldType_Enum:
		return fmt.Sprintf("%s.%s", fd.Complex.Name, fd.DefaultValue())
	case model.FieldType_String:
		return fmt.Sprintf("\"%s\"", fd.DefaultValue())
	case model.FieldType_Float:
		return fmt.Sprintf("%sf", fd.DefaultValue())
	}

	return fd.DefaultValue()
}

type javaStructModel struct {
	*model.Descriptor
	Fields        []javaField
	IndexedFields []javaField // 与javaField.IndexKeys组成树状的索引层次
}

func (self *javaStructModel) JavaClassHeader() string {

	// zjwps 提供需求
	return self.File.Pragma.GetString("JavaClassHeader")
}

func (self *javaStructModel) DefinedTable() string {
	return self.File.Name
}

func (self *javaStructModel) Name() string {
	return self.Descriptor.Name
}

func (self *javaStructModel) IsCombine() bool {
	return self.Descriptor.Usage == model.DescriptorUsage_CombineStruct
}

type javaFileModel struct {
	Namespace   string
	ToolVersion string
	Classes     []*javaStructModel
	Enums       []*javaStructModel
	Indexes     []javaIndexField // 全局的索引

	VerticalFields []javaField

	GenSerializeCode bool
	BuildID string
}

type javaPrinter struct {
}

func (self *javaPrinter) Run(g *Globals,outFile string) map[string]*Stream {

	tpl, err := template.New("java").Parse(javaTemplate)
	if err != nil {
		log.Errorln(err)
		return nil
	}


	allTypes := map[string]javaFileModel {}


	var m javaFileModel

	if g.PackageName != "" {
		m.Namespace = g.PackageName
	} else {
		m.Namespace = g.FileDescriptor.Pragma.GetString("Package")
	}

	m.ToolVersion = g.Version
	m.GenSerializeCode = g.GenCSSerailizeCode

	// combinestruct的全局索引
	for _, ti := range g.GlobalIndexes {

		// 索引也限制
		if !ti.Index.Parent.File.MatchTag(".java") {
			continue
		}

		m.Indexes = append(m.Indexes, javaIndexField{TableIndex: ti})
	}

	// 遍历所有类型
	for _, d := range g.FileDescriptor.Descriptors {

		var mtmp javaFileModel
		mtmp.Indexes = m.Indexes
		mtmp.ToolVersion = m.ToolVersion
		mtmp.GenSerializeCode = m.GenSerializeCode
		mtmp.Namespace = m.Namespace

		// 这给被限制输出
		if !d.File.MatchTag(".java") {
			log.Infof("%s: %s", i18n.String(i18n.Printer_IgnoredByOutputTag), d.Name)
			continue
		}

		var sm javaStructModel
		sm.Descriptor = d

		switch d.Kind {
		case model.DescriptorKind_Struct:
			m.Classes = append(m.Classes, &sm)

			mtmp.Classes = append(mtmp.Classes,&sm)
			

		case model.DescriptorKind_Enum:
			m.Enums = append(m.Enums, &sm)

			mtmp.Enums = append(mtmp.Enums,&sm)

		}
		allTypes[sm.Name()] = mtmp;
		// 遍历字段
		for _, fd := range d.Fields {

			// 对CombineStruct的XXDefine对应的字段
			if d.Usage == model.DescriptorUsage_CombineStruct {

				// 这个字段被限制输出
				if fd.Complex != nil && !fd.Complex.File.MatchTag(".java") {
					continue
				}

				// 这个结构有索引才创建
				if fd.Complex != nil && len(fd.Complex.Indexes) > 0 {

					// 被索引的结构
					indexedField := javaField{FieldDescriptor: fd, parentStruct: &sm}

					// 索引字段
					for _, key := range fd.Complex.Indexes {
						indexedField.IndexKeys = append(indexedField.IndexKeys, key)
					}

					sm.IndexedFields = append(sm.IndexedFields, indexedField)
				}

				if fd.Complex != nil && fd.Complex.File.Pragma.GetBool("Vertical") {
					m.VerticalFields = append(m.VerticalFields, javaField{FieldDescriptor: fd, parentStruct: &sm})
				}

			}

			csField := javaField{FieldDescriptor: fd, parentStruct: &sm}

			sm.Fields = append(sm.Fields, csField)

		}

	}

	bf := NewStream()

	var md5Buffer bytes.Buffer
	err = tpl.Execute(&md5Buffer, &m)
	if err != nil {
		log.Errorln(err)
		return nil
	}

	m.BuildID = fmt.Sprintf("%x", md5.Sum(bf.Buffer().Bytes()))
	g.BuildID = m.BuildID

	err = tpl.Execute(bf.Buffer(), &m)
	if err != nil {
		log.Errorln(err)
		return nil
	}

	// var extindex int = len(outFile) - 5;
	var outFileName string = strings.Replace(outFile, ".java", "", 1 )
	log.Infof("--->>>>>(%s)\n", outFileName)


	log.Infof("--->>>>>(%s)\n", outFile)

	streamresult := map[string]*Stream {}

	var pkgPath string= strings.Replace(m.Namespace, ".", "/", -1 )

	for k, v := range allTypes {
		// fmt.Println(k, v)

		for _, classfd := range v.Classes {
			log.Infof("----(%s---> class %s)\n", k,classfd.Name() )
		}
		for _, enumfd := range v.Enums {
			log.Infof("----(%s---> enum %s)\n", k,enumfd.Name() )
		}
		v.BuildID = m.BuildID;

		outputstream := NewStream()

		tpltmp, err := template.New("java").Parse(javaTemplate)
		if err != nil {
			log.Errorln(err)
			return nil
		}

		err = tpltmp.Execute(outputstream.Buffer(), &v)

		if err != nil {
			log.Errorln(err)
			return nil
		}
		
		
		streamresult[outFileName+"/"+pkgPath+"/"+k+".java"] = outputstream
		
	}


	// return bf
	
	// streamresult[outFile] = bf
	return streamresult
}

func init() {

	RegisterPrinter("java", &javaPrinter{})

}
